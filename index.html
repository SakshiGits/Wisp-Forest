<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wisp Forest Game</title>
  <!-- Orange ID Dependencies -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://public-cdn-files.pages.dev/bedrock-passport.umd.js" id="bedrock-script"></script>
  <!-- Tailwind CSS for styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      background-color: black;
    }
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    #uiOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      min-height: 100vh;
      max-height: 100vh;
      overflow-y: auto;
      background: url('https://images.unsplash.com/photo-1623331492167-004ab14d8736') no-repeat center/cover;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      box-sizing: border-box;
      z-index: 10;
      color: #e0e0e0;
      font-family: 'Arial', sans-serif;
    }
    #gameOverOverlay, #winOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      max-height: 100vh;
      overflow-y: auto;
      background: url('https://images.unsplash.com/photo-1448375240586-882707db888b') no-repeat center/cover;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      box-sizing: border-box;
      z-index: 10;
      color: #e0e0e0;
      font-family: 'Arial', sans-serif;
    }
    #uiOverlay h1 {
      color: #00ff88;
      text-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88;
      font-size: 48px;
      margin-bottom: 10px;
      animation: glow 2s ease-in-out infinite;
    }
    #gameOverOverlay h1 {
      color: #ff3333;
      text-shadow: 0 0 10px #ff3333, 0 0 20px #ff3333;
      font-size: 48px;
      margin-bottom: 10px;
      animation: glow 2s ease-in-out infinite;
    }
    #winOverlay h1 {
      color: #00ff88;
      text-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88;
      font-size: 48px;
      margin-bottom: 10px;
      animation: glow 2s ease-in-out infinite;
    }
    #uiOverlay p, #gameOverOverlay p, #winOverlay p {
      font-size: 18px;
      max-width: 600px;
      text-align: center;
      margin-bottom: 20px;
    }
    #totalTokensDisplay {
      font-size: 18px;
      max-width: 600px;
      text-align: center;
      margin-bottom: 20px;
      color: #ffcc00;
      text-shadow: 0 0 5px #ffcc00;
    }
    #uiOverlay button, #gameOverOverlay button, #winOverlay button, #quitButton {
      width: 150px;
      padding: 12px 0;
      margin: 10px;
      font-size: 18px;
      background: linear-gradient(45deg, #00ff88, #00cc66);
      border: none;
      border-radius: 5px;
      color: white;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-sizing: border-box;
    }
    #loginButton {
      background: #F5A623 !important;
      border: 2px solid #F5A623 !important;
      width: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      padding: 12px 0;
      margin: 10px;
      border-radius: 5px;
      color: white;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    #loginButton img {
      width: 24px;
      height: 24px;
      margin-right: 8px;
    }
    #retryButton {
      background: #F5A623 !important;
      border: 2px solid #F5A623 !important;
      width: 200px;
      font-size: 16px;
      padding: 12px 0;
      margin: 10px;
      border-radius: 5px;
      color: white;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      display: none;
    }
    #uiOverlay button:hover, #gameOverOverlay button:hover, #winOverlay button:hover, #quitButton:hover, #retryButton:hover {
      transform: scale(1.1);
      box-shadow: 0 0 15px #00ff88;
    }
    #loginButton:hover, #retryButton:hover {
      transform: scale(1.1);
      box-shadow: 0 0 15px #F5A623;
    }
    #uiOverlay button:disabled {
      background: grey;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    @keyframes glow {
      0%, 100% { text-shadow: 0 0 10px currentColor, 0 0 20px currentColor; }
      50% { text-shadow: 0 0 20px currentColor, 0 0 30px currentColor; }
    }
    #instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
      font-family: sans-serif;
      font-size: 14px;
      z-index: 5;
    }
    #staminaBarContainer {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #00ff88;
      border-radius: 5px;
      z-index: 5;
    }
    #staminaBar {
      height: 100%;
      background: linear-gradient(90deg, #00ff88, #00cc66);
      width: 100%;
      transition: width 0.2s;
    }
    #loadingMsg {
      color: white;
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-family: sans-serif;
      background: rgba(0, 0, 0, 0.6);
      padding: 5px 15px;
      border-radius: 5px;
      z-index: 15;
    }
    #warningMsg {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      color: red;
      font-family: sans-serif;
      font-size: 18px;
      background: rgba(0, 0, 0, 0.6);
      padding: 5px 15px;
      border-radius: 5px;
      z-index: 5;
      display: none;
    }
    #quitButton {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      z-index: 5;
    }
    #userInfo {
      font-size: 16px;
      color: #00ff88;
      text-shadow: 0 0 5px #00ff88;
      margin-bottom: 10px;
    }
    #guestNote {
      font-size: 16px;
      color: #ffcc00;
      text-shadow: 0 0 5px #ffcc00;
      margin-bottom: 10px;
      max-width: 600px;
      text-align: center;
    }
    #bedrock-login-widget {
      max-width: 480px;
      margin: 20px auto;
      display: none;
    }
  </style>
</head>
<body>
  <div id="uiOverlay">
    <h1>Wisp Forest Game</h1>
    <div id="userInfo"></div>
    <div id="guestNote">Play as Guest without login, but ORNG tokens require Orange ID login.</div>
    <p>Embark on a thrilling adventure through a mystical forest. Escape monsters and reach the glowing light to claim victory. Hide in bushes and use your stamina wisely to avoid danger.</p>
    <div id="bedrock-login-widget"></div>
    <button id="loginButton">
      <img src="https://irp.cdn-website.com/e81c109a/dms3rep/multi/orange-web3-logo-v2a-20241018.svg" alt="Orange Web3 Icon">
      Sign in with Orange ID
    </button>
    <button id="retryButton" style="display: none;">Retry Orange ID Login</button>
    <button id="logoutButton" style="display: none;">Logout</button>
    <button id="startButton">Start Game</button>
    <button id="exitButton">Exit</button>
  </div>
  <div id="gameOverOverlay">
    <h1>Game Over</h1>
    <p>A monster caught you! Try again to escape and reach the glowing light!</p>
    <p id="totalTokensDisplay">Total ORNG Tokens Collected: 0</p>
    <button id="voteButton">Vote for this Game</button>
    <button id="restartButtonGameOver">Restart</button>
  </div>
  <div id="winOverlay">
    <h1>You Win!</h1>
    <p id="winMessage">You reached the glowing light! Try again for a faster time!</p>
    <p id="totalTokensDisplay">Total ORNG Tokens Collected: 0</p>
    <button id="voteButtonWin">Vote for this Game</button>
    <button id="restartButtonWin">Restart</button>
  </div>
  <div id="instructions" style="display: none;">
    <strong>Controls:</strong><br>
    W/A/S/D: Move<br>
    Shift: Sprint (limited stamina)<br>
    Space: Jump<br>
    C: Crouch<br>
    E: Climb Up<br>
    Q: Climb Down<br>
    Esc: Quit Game<br>
    <br>
    Follow the guiding light to reach the glowing light and win. Hide in bushes to avoid monsters!
  </div>
  <div id="staminaBarContainer" style="display: none;">
    <div id="staminaBar"></div>
  </div>
  <div id="loadingMsg">Loading...</div>
  <div id="warningMsg"></div>
  <button id="quitButton">Quit Game</button>
  <canvas id="renderCanvas"></canvas>

  <!-- Babylon.js Scripts -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

  <script>
    (function () {
      // Verify script dependencies
      if (!window.React) {
        console.error("React failed to load");
        document.getElementById("loadingMsg").innerText = "Error: React script failed. Check Console.";
        return;
      }
      if (!window.ReactDOM) {
        console.error("ReactDOM failed to load");
        document.getElementById("loadingMsg").innerText = "Error: ReactDOM script failed. Check Console.";
        return;
      }
      if (!window.BABYLON) {
        console.error("Babylon.js failed to load");
        document.getElementById("loadingMsg").innerText = "Error: Game engine failed. Check Console.";
        return;
      }

      let isAuthenticated = false;
      let username = "Guest";
      let userId = `guest-${Date.now()}`;
      let totalTokens = parseInt(sessionStorage.getItem("totalTokens")) || 0;
      let startTime = null;
      let elapsedTime = null;
      let widgetRoot = null;
      let widgetInitialized = false;
      let scene = null;
      let monsters = [];
      let spawnMonsters = null;
      let quitGame = null;
      let backgroundMusic = null;
      let monsterAlertSound = null;
      let lastPosition = null;
      let stuckTime = 0;

      // Orange ID config
      const bedrockConfig = {
        baseUrl: "https://api.bedrockpassport.com",
        authCallbackUrl: "https://orange-wisp-forest.surge.sh",
        tenantId: "orange-dchi1plf6x",
        subscriptionKey: "a2d4ae2ddabe4bd2b696b51a883074fd"
      };

      // Fallback for Bedrock script loading
      const loadBedrockScript = (callback) => {
        const script = document.createElement("script");
        script.src = "https://public-cdn-files.pages.dev/bedrock-passport.umd.js";
        script.id = "bedrock-script";
        script.onload = () => {
          console.log("Bedrock Passport loaded successfully");
          callback(true);
        };
        script.onerror = () => {
          console.error("Failed to load Bedrock Passport");
          document.getElementById("loadingMsg").innerText = "Error: Orange ID script failed. Retrying...";
          setTimeout(() => loadBedrockScript(callback), 2000);
        };
        document.head.appendChild(script);
      };

      const initializeWidget = () => {
        if (widgetInitialized || widgetRoot) return;
        console.log("Initializing Orange ID widget...");
        const container = document.getElementById("bedrock-login-widget");
        try {
          widgetRoot = ReactDOM.createRoot(container);
          widgetRoot.render(
            React.createElement(
              window.Bedrock.BedrockPassportProvider,
              { ...bedrockConfig, enableWalletConnect: false },
              React.createElement(window.Bedrock.LoginPanel, {
                title: "Sign in to",
                logo: "https://irp.cdn-website.com/e81c109a/dms3rep/multi/orange-web3-logo-v2a-20241018.svg",
                logoAlt: "Orange Web3",
                separatorText: "OR",
                features: {
                  enableAppleLogin: true,
                  enableGoogleLogin: true,
                  enableEmailLogin: false
                },
                titleClass: "text-xl font-bold",
                logoClass: "ml-2 md:h-8 h-6",
                panelClass: "container p-2 md:p-8 rounded-2xl max-w-[480px]",
                buttonClass: "hover:border-orange-500",
                separatorTextClass: "bg-orange-900 text-gray-500",
                separatorClass: "bg-orange-900",
                linkRowClass: "justify-center",
                headerClass: "justify-center"
              })
            )
          );
          widgetInitialized = true;
          document.getElementById("loginButton").style.display = "none";
          document.getElementById("retryButton").style.display = "none";
          document.getElementById("bedrock-login-widget").style.display = "block";
          document.getElementById("loadingMsg").innerText = "Login widget loaded. Please sign in.";
        } catch (error) {
          console.error("Widget initialization failed:", error);
          document.getElementById("loadingMsg").innerText = "Error: Login widget failed. Try again.";
          widgetInitialized = false;
          widgetRoot = null;
        }
      };

      const cleanupWidget = () => {
        console.log("Cleaning up widget...");
        if (widgetRoot) {
          widgetRoot.unmount();
          widgetRoot = null;
        }
        widgetInitialized = false;
        document.getElementById("bedrock-login-widget").innerHTML = "";
        document.getElementById("bedrock-login-widget").style.display = "none";
      };

      const attemptLogin = () => {
        console.log("Attempting login...");
        if (window.Bedrock && window.Bedrock.BedrockPassportProvider) {
          initializeWidget();
        } else {
          console.error("Bedrock not available");
          document.getElementById("loadingMsg").innerText = "Error: Orange ID unavailable. Retrying...";
          loadBedrockScript((success) => {
            if (success) {
              initializeWidget();
            } else {
              document.getElementById("loadingMsg").innerText = "Error: Orange ID failed. Play as Guest.";
              document.getElementById("retryButton").style.display = "block";
              isAuthenticated = false;
              username = "Guest";
              userId = `guest-${Date.now()}`;
              sessionStorage.setItem("username", username);
              sessionStorage.setItem("userId", userId);
              updateUI();
            }
          });
        }
      };

      const updateUI = () => {
        console.log("Updating UI: isAuthenticated=", isAuthenticated, "username=", username, "userId=", userId);
        const loginButton = document.getElementById("loginButton");
        const retryButton = document.getElementById("retryButton");
        const logoutButton = document.getElementById("logoutButton");
        const startButton = document.getElementById("startButton");
        const userInfo = document.getElementById("userInfo");
        const loginWidget = document.getElementById("bedrock-login-widget");
        const guestNote = document.getElementById("guestNote");

        if (isAuthenticated) {
          loginButton.style.display = "none";
          retryButton.style.display = "none";
          logoutButton.style.display = "block";
          loginWidget.style.display = "none";
          guestNote.style.display = "none";
        } else {
          loginButton.style.display = "block";
          retryButton.style.display = "none";
          logoutButton.style.display = "none";
          loginWidget.style.display = "none";
          guestNote.style.display = "block";
        }
        startButton.disabled = false;
        userInfo.innerHTML = `Welcome, ${username}`;
      };

      document.getElementById("loginButton").addEventListener("click", () => {
        console.log("Login button clicked");
        attemptLogin();
      });

      document.getElementById("retryButton").addEventListener("click", () => {
        console.log("Retry button clicked");
        document.getElementById("loadingMsg").innerText = "Retrying Orange ID login...";
        document.getElementById("retryButton").style.display = "none";
        cleanupWidget();
        attemptLogin();
      });

      document.getElementById("logoutButton").addEventListener("click", () => {
        console.log("Logout button clicked");
        isAuthenticated = false;
        username = "Guest";
        userId = `guest-${Date.now()}`;
        totalTokens = 0;
        sessionStorage.removeItem("orangeIdToken");
        sessionStorage.removeItem("refreshToken");
        sessionStorage.removeItem("username");
        sessionStorage.removeItem("userId");
        sessionStorage.removeItem("totalTokens");
        cleanupWidget();
        updateUI();
        document.getElementsByName("totalTokensDisplay").forEach(el => {
          el.innerText = `Total ORNG Tokens Collected: 0`;
        });
      });

      const parseJwt = (token) => {
        try {
          const base64Url = token.split('.')[1];
          const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
          const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
          }).join(''));
          return JSON.parse(jsonPayload);
        } catch (e) {
          console.error("Failed to parse JWT:", e);
          return null;
        }
      };

      const fetchTotalTokens = async () => {
        if (!isAuthenticated) {
          totalTokens = 0;
          sessionStorage.setItem("totalTokens", totalTokens);
          document.getElementsByName("totalTokensDisplay").forEach(el => {
            el.innerText = `Total ORNG Tokens Collected: 0`;
          });
          return;
        }

        const token = sessionStorage.getItem("orangeIdToken");
        if (!token) return;

        try {
          const response = await fetch(`${bedrockConfig.baseUrl}/rewards/total`, {
            method: "GET",
            headers: {
              "Authorization": `Bearer ${token}`,
              "Ocp-Apim-Subscription-Key": bedrockConfig.subscriptionKey
            }
          });
          if (response.ok) {
            const data = await response.json();
            totalTokens = data.totalTokens || 0;
            sessionStorage.setItem("totalTokens", totalTokens);
            document.getElementsByName("totalTokensDisplay").forEach(el => {
              el.innerText = `Total ORNG Tokens Collected: ${totalTokens}`;
            });
            console.log("Fetched total tokens:", totalTokens);
          } else {
            console.error("Failed to fetch total tokens:", response.status);
            totalTokens = parseInt(sessionStorage.getItem("totalTokens")) || 0;
            document.getElementsByName("totalTokensDisplay").forEach(el => {
              el.innerText = `Total ORNG Tokens Collected: ${totalTokens}`;
            });
          }
        } catch (error) {
          console.error("Error fetching total tokens:", error);
          totalTokens = parseInt(sessionStorage.getItem("totalTokens")) || 0;
          document.getElementsByName("totalTokensDisplay").forEach(el => {
            el.innerText = `Total ORNG Tokens Collected: ${totalTokens}`;
          });
        }
      };

      const processCallback = async (token, refreshToken) => {
        console.log("Processing callback with token:", token);
        try {
          let user = { name: "Guest", id: `guest-${Date.now()}` };
          const jwtData = parseJwt(token);
          if (jwtData && jwtData.email && jwtData.sub) {
            user.name = jwtData.email.split('@')[0] || "Guest";
            user.id = jwtData.sub;
            console.log("User from JWT:", user);
          } else {
            throw new Error("Invalid JWT data");
          }
          isAuthenticated = true;
          username = user.name;
          userId = user.id;
          sessionStorage.setItem("orangeIdToken", token);
          sessionStorage.setItem("refreshToken", refreshToken);
          sessionStorage.setItem("username", username);
          sessionStorage.setItem("userId", userId);
          window.history.replaceState({}, document.title, window.location.pathname);
          document.getElementById("loadingMsg").innerText = "Login successful! Start the game.";
          cleanupWidget();
          updateUI();
          await fetchTotalTokens();
        } catch (error) {
          console.error("Callback processing failed:", error);
          document.getElementById("loadingMsg").innerText = "Authentication error. Play as Guest.";
          isAuthenticated = false;
          username = "Guest";
          userId = `guest-${Date.now()}`;
          sessionStorage.setItem("username", username);
          sessionStorage.setItem("userId", userId);
          updateUI();
        }
      };

      const handleCallback = () => {
        console.log("Handling callback...");
        const params = new URLSearchParams(window.location.search);
        const token = params.get("token");
        const refreshToken = params.get("refreshToken");
        if (token && refreshToken) {
          processCallback(token, refreshToken);
        } else {
          console.warn("No token or refreshToken in URL");
          document.getElementById("loadingMsg").innerText = "Login callback failed. Try again.";
        }
      };

      const refreshTokenIfNeeded = async () => {
        console.log("Checking if token refresh is needed...");
        const token = sessionStorage.getItem("orangeIdToken");
        const refreshToken = sessionStorage.getItem("refreshToken");
        if (!token || !refreshToken) {
          console.warn("No token or refresh token available");
          return false;
        }

        try {
          const response = await fetch(`${bedrockConfig.baseUrl}/verify`, {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${token}`,
              "Ocp-Apim-Subscription-Key": bedrockConfig.subscriptionKey
            }
          });
          if (response.ok) {
            console.log("Token is valid");
            return true;
          } else {
            console.log("Token invalid, attempting refresh...");
            const refreshResponse = await fetch(`${bedrockConfig.baseUrl}/refresh`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Ocp-Apim-Subscription-Key": bedrockConfig.subscriptionKey
              },
              body: JSON.stringify({ refreshToken })
            });
            if (refreshResponse.ok) {
              const { token: newToken, refreshToken: newRefreshToken } = await refreshResponse.json();
              sessionStorage.setItem("orangeIdToken", newToken);
              sessionStorage.setItem("refreshToken", newRefreshToken);
              console.log("Token refreshed successfully");
              return true;
            } else {
              throw new Error("Refresh token invalid");
            }
          }
        } catch (error) {
          console.error("Token refresh failed:", error);
          sessionStorage.removeItem("orangeIdToken");
          sessionStorage.removeItem("refreshToken");
          isAuthenticated = false;
          username = "Guest";
          userId = `guest-${Date.now()}`;
          sessionStorage.setItem("username", username);
          sessionStorage.setItem("userId", userId);
          updateUI();
          return false;
        }
      };

      const checkSession = async () => {
        console.log("Checking session...");
        const token = sessionStorage.getItem("orangeIdToken");
        const refreshToken = sessionStorage.getItem("refreshToken");
        username = sessionStorage.getItem("username") || "Guest";
        userId = sessionStorage.getItem("userId") || `guest-${Date.now()}`;
        if (token && refreshToken) {
          const isValid = await refreshTokenIfNeeded();
          if (isValid) {
            isAuthenticated = true;
            await fetchTotalTokens();
          } else {
            console.warn("Session invalid, cleared");
            isAuthenticated = false;
            username = "Guest";
            userId = `guest-${Date.now()}`;
            sessionStorage.setItem("username", username);
            sessionStorage.setItem("userId", userId);
            totalTokens = 0;
            sessionStorage.setItem("totalTokens", totalTokens);
          }
        }
        updateUI();
      };

      const voteForGame = async () => {
        console.log("Initiating vote for userId:", userId);
        const token = sessionStorage.getItem("orangeIdToken");
        const headers = {
          "Content-Type": "application/json",
          "Ocp-Apim-Subscription-Key": bedrockConfig.subscriptionKey
        };
        if (token && isAuthenticated) {
          headers["Authorization"] = `Bearer ${token}`;
        }

        try {
          const response = await fetch(`${bedrockConfig.baseUrl}/vote`, {
            method: "POST",
            headers: headers,
            body: JSON.stringify({
              projectId: bedrockConfig.tenantId,
              userId: userId,
              voteType: "game_submission",
              submissionId: "wisp_forest_game"
            })
          });
          console.log("Vote response:", response.status);
          if (response.ok) {
            document.getElementById("warningMsg").innerText = "Thank you for voting!";
            document.getElementById("warningMsg").style.display = "block";
            setTimeout(() => {
              document.getElementById("warningMsg").style.display = "none";
            }, 3000);
          } else {
            const errorData = await response.json().catch(() => ({}));
            console.error("Vote failed:", response.status, errorData);
            let errorMsg = "Voting failed. Try again.";
            if (response.status === 401) errorMsg = "Voting requires sign-in for this session.";
            else if (response.status === 403) errorMsg = "Not authorized to vote.";
            else if (response.status === 400) errorMsg = `Invalid vote: ${errorData.message || "Bad request"}`;
            document.getElementById("warningMsg").innerText = errorMsg;
            document.getElementById("warningMsg").style.display = "block";
          }
        } catch (error) {
          console.error("Voting error:", error);
          document.getElementById("warningMsg").innerText = "Voting failed: Network error. Try again.";
          document.getElementById("warningMsg").style.display = "block";
        }
      };

      const awardTokens = async (timeInSeconds) => {
        console.log("Awarding tokens for time:", timeInSeconds);
        if (!isAuthenticated) {
          console.log("No tokens: Login required");
          document.getElementById("warningMsg").innerText = "Login required to earn ORNG tokens.";
          document.getElementById("warningMsg").style.display = "block";
          document.getElementsByName("totalTokensDisplay").forEach(el => {
            el.innerText = `Total ORNG Tokens Collected: ${totalTokens}`;
          });
          return { success: false, tokens: 0 };
        }

        const tokenValid = await refreshTokenIfNeeded();
        if (!tokenValid) {
          console.warn("Token invalid, prompting re-login");
          document.getElementById("warningMsg").innerText = "Session expired. Please sign in again.";
          document.getElementById("warningMsg").style.display = "block";
          document.getElementsByName("totalTokensDisplay").forEach(el => {
            el.innerText = `Total ORNG Tokens Collected: ${totalTokens}`;
          });
          return { success: false, tokens: 0 };
        }

        let tokens = 0;
        if (timeInSeconds < 30) tokens = 10;
        else if (timeInSeconds < 60) tokens = 5;
        else tokens = 2;

        const token = sessionStorage.getItem("orangeIdToken");
        try {
          console.log(`Submitting ${tokens} ORNG tokens for userId: ${userId}`);
          const response = await fetch(`${bedrockConfig.baseUrl}/rewards`, {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${token}`,
              "Content-Type": "application/json",
              "Ocp-Apim-Subscription-Key": bedrockConfig.subscriptionKey
            },
            body: JSON.stringify({
              projectId: bedrockConfig.tenantId,
              userId: userId,
              tokens: tokens,
              timeInSeconds: timeInSeconds,
              submissionId: "wisp_forest_game"
            })
          });
          console.log("Rewards response:", response.status);
          if (response.ok) {
            await fetchTotalTokens();
            document.getElementById("warningMsg").innerText = `Awarded ${tokens} ORNG tokens!`;
            document.getElementById("warningMsg").style.display = "block";
            setTimeout(() => {
              document.getElementById("warningMsg").style.display = "none";
            }, 3000);
            return { success: true, tokens };
          } else {
            const errorData = await response.json().catch(() => ({}));
            console.error("Reward failed:", response.status, errorData);
            let errorMsg = "Failed to award tokens. Try again.";
            if (response.status === 401) errorMsg = "Session expired. Please sign in again.";
            else if (response.status === 403) errorMsg = "Not authorized to award tokens.";
            else if (response.status === 400) errorMsg = `Invalid request: ${errorData.message || "Bad request"}`;
            document.getElementById("warningMsg").innerText = errorMsg;
            document.getElementById("warningMsg").style.display = "block";
            document.getElementsByName("totalTokensDisplay").forEach(el => {
              el.innerText = `Total ORNG Tokens Collected: ${totalTokens}`;
            });
            return { success: false, tokens };
          }
        } catch (error) {
          console.error("Reward error:", error);
          document.getElementById("warningMsg").innerText = "Failed to award tokens: Network error. Try again.";
          document.getElementById("warningMsg").style.display = "block";
          document.getElementsByName("totalTokensDisplay").forEach(el => {
            el.innerText = `Total ORNG Tokens Collected: ${totalTokens}`;
          });
          return { success: false, tokens };
        }
      };

      const canvas = document.getElementById("renderCanvas");
      const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
      let inputMap = {};
      let canJump = true;
      let isCrouching = false;
      let isClimbing = false;
      let climbStartTime = 0;
      let stamina = 100;
      let isSprinting = false;
      let gameStarted = false;
      let lastMonsterWarning = 0;

      // Force canvas focus on click
      canvas.addEventListener("click", () => {
        canvas.focus();
        console.log("Canvas clicked and focused");
      });

      // Input handling
      window.addEventListener("keydown", e => {
        inputMap[e.key.toLowerCase()] = true;
        console.log(`Key pressed: ${e.key}, InputMap: [${Object.keys(inputMap).filter(k => inputMap[k]).join(", ")}]`);
        if (gameStarted && ["w", "a", "s", "d"].includes(e.key.toLowerCase()) && !inputMap[e.key.toLowerCase()]) {
          document.getElementById("warningMsg").innerText = `Input failed: Press ${e.key} again or click canvas.`;
          document.getElementById("warningMsg").style.display = "block";
        }
      });
      window.addEventListener("keyup", e => {
        inputMap[e.key.toLowerCase()] = false;
        console.log(`Key released: ${e.key}, InputMap: [${Object.keys(inputMap).filter(k => inputMap[k]).join(", ")}]`);
      });

      const getRandomLightPosition = () => {
        const x = Math.random() * 60 - 30;
        const z = Math.random() * 60 - 30;
        return new BABYLON.Vector3(x, 7, z);
      };

      class Monster {
        constructor(position, scene) {
          this.scene = scene;
          this.mesh = null;
          this.baseSpeed = 0.12;
          this.speed = this.baseSpeed;
          this.detectRadius = 12;
          this.isChasing = false;
          this.target = null;
          this.isLoaded = false;
          this.patrolTarget = null;
          this.isPaused = false;
          this.pauseEndTime = 0;
          this.nextPatrolTime = performance.now() + Math.random() * 5000 + 5000;

          console.log("Loading monster.glb at position:", position);
          BABYLON.SceneLoader.ImportMeshAsync("", "./assets/", "monster.glb", scene)
            .then((result) => {
              this.mesh = result.meshes[0];
              this.mesh.scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);
              this.mesh.position = position;
              this.mesh.checkCollisions = true;
              this.mesh.isPickable = true;
              this.isLoaded = true;
              console.log("Monster loaded at:", position);
              document.getElementById("loadingMsg").innerText = "Monster loaded!";
            })
            .catch((error) => {
              console.error("Monster load failed:", error);
              document.getElementById("loadingMsg").innerText = "Error: Monster failed to load.";
            });
        }

        setRandomPatrolTarget() {
          const x = Math.random() * 40 - 20;
          const z = Math.random() * 40 - 20;
          this.patrolTarget = new BABYLON.Vector3(x, 1, z);
          this.nextPatrolTime = performance.now() + Math.random() * 5000 + 5000;
          console.log("Monster patrol target set to:", this.patrolTarget);
        }

        moveTo(destination) {
          if (!this.mesh || !this.isLoaded) return;
          const direction = destination.subtract(this.mesh.position);
          direction.y = 0;
          const distance = direction.length();
          if (distance < 0.5) {
            if (!this.isChasing && !this.isPaused) this.setRandomPatrolTarget();
            return;
          }
          direction.normalize();
          this.mesh.position.addInPlace(direction.scale(this.speed));
          console.log("Monster moving to:", destination, "Position:", this.mesh.position);
        }

        detectPlayer(camera, isPlayerHiding) {
          if (!this.mesh || !this.isLoaded) return;
          const distance = BABYLON.Vector3.Distance(camera.position, this.mesh.position);
          this.isChasing = distance < this.detectRadius && !isPlayerHiding && !this.isPaused;
          this.target = this.isChasing ? camera : null;
          if (this.isChasing) console.log("Monster chasing player, distance:", distance);
        }

        update() {
          if (!this.mesh || !this.isLoaded) return;
          if (this.isPaused && performance.now() < this.pauseEndTime) {
            if (this.patrolTarget) this.moveTo(this.patrolTarget);
            return;
          } else if (this.isPaused) {
            this.isPaused = false;
            this.speed = this.baseSpeed;
            this.setRandomPatrolTarget();
            console.log("Monster resumed patrolling");
          }
          if (this.isChasing && this.target) {
            this.moveTo(this.target.position);
          } else if (this.patrolTarget) {
            this.moveTo(this.patrolTarget);
          } else {
            this.setRandomPatrolTarget();
          }
          if (!this.isChasing && performance.now() > this.nextPatrolTime) {
            this.setRandomPatrolTarget();
          }
        }

        pauseForObservation() {
          this.isPaused = true;
          this.isChasing = false;
          this.speed = 0.05;
          this.pauseEndTime = performance.now() + (5000 + Math.random() * 2000);
          console.log("Monster paused for observation");
        }

        getDistanceToPlayer(camera) {
          if (!this.mesh || !this.isLoaded) return Infinity;
          return BABYLON.Vector3.Distance(camera.position, this.mesh.position);
        }
      }

      class StealthMechanic {
        constructor(camera, scene) {
          this.camera = camera;
          this.scene = scene;
          this.isHiding = false;
          this.bushes = [];

          this.scene.meshes.forEach(mesh => {
            if (mesh.name.toLowerCase().includes("bush")) {
              this.bushes.push(mesh);
              console.log("Bush detected:", mesh.name, "Position:", mesh.position);
            }
          });
        }

        checkIfHiding() {
          const playerPos = this.camera.position;
          this.isHiding = false;

          this.bushes.forEach(bush => {
            const distance = BABYLON.Vector3.Distance(playerPos, bush.position);
            if (distance < 1.5) {
              this.isHiding = true;
              console.log("Player hiding in bush:", bush.name, "Distance:", distance);
            }
          });
        }

        update() {
          this.checkIfHiding();
        }
      }

      const createScene = async (lightPosition = new BABYLON.Vector3(30, 7, 30)) => {
        console.log("Creating scene...");
        document.getElementById("loadingMsg").innerText = "Loading scene...";
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.1, 1);
        scene.gravity = new BABYLON.Vector3(0, -0.9, 0);
        scene.collisionsEnabled = true;

        const camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 10, -10), scene);
        camera.attachControl(canvas, true);
        camera.speed = 0.8;
        camera.minZ = 0.1;
        camera.keysUp = [87]; // W
        camera.keysDown = [83]; // S
        camera.keysLeft = [65]; // A
        camera.keysRight = [68]; // D
        camera.checkCollisions = true;
        camera.applyGravity = true;
        camera.ellipsoid = new BABYLON.Vector3(0.3, 0.9, 0.3);
        console.log("Camera setup: Position =", camera.position, "Collisions =", camera.checkCollisions);

        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);
        light.intensity = 0.8;

        const collisionGround = BABYLON.MeshBuilder.CreateGround("collisionGround", { width: 200, height: 200 }, scene);
        collisionGround.position = new BABYLON.Vector3(0, -0.1, 0);
        collisionGround.checkCollisions = true;
        collisionGround.isPickable = true;
        collisionGround.isVisible = false;
        console.log("Collision ground created at y=-0.1");

        const fallbackGround = BABYLON.MeshBuilder.CreateGround("fallbackGround", { width: 200, height: 200 }, scene);
        fallbackGround.position = new BABYLON.Vector3(0, -1.1, 0);
        fallbackGround.checkCollisions = true;
        fallbackGround.isPickable = true;
        fallbackGround.isVisible = false;
        console.log("Fallback ground created at y=-1.1");

        try {
          console.log("Loading wisp_forest.glb...");
          document.getElementById("loadingMsg").innerText = "Loading forest environment...";
          const result = await BABYLON.SceneLoader.ImportMeshAsync("", "./assets/", "wisp_forest.glb", scene);
          const environment = result.meshes[0];
          environment.position = new BABYLON.Vector3(0, 0, 0);
          environment.scaling = new BABYLON.Vector3(1, 1, 1);
          result.meshes.forEach(mesh => {
            mesh.checkCollisions = true;
            mesh.isPickable = true;
            mesh.position.y = 0;
            console.log("Loaded mesh:", mesh.name, "Position =", mesh.position);
          });
          scene.particleSystems?.forEach(particleSystem => particleSystem.stop());
          console.log("Wisp forest loaded successfully");
          document.getElementById("loadingMsg").innerText = "Environment loaded!";
        } catch (error) {
          console.error("Failed to load wisp_forest.glb:", error);
          document.getElementById("loadingMsg").innerText = "Error: Forest failed to load. Using fallback.";
          const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 100, height: 100 }, scene);
          ground.position = new BABYLON.Vector3(0, 0, 0);
          ground.checkCollisions = true;
          ground.isPickable = true;
          ground.material = new BABYLON.StandardMaterial("groundMat", scene);
          ground.material.diffuseColor = new BABYLON.Color3(0.2, 0.5, 0.2);
          console.log("Visible fallback ground created at y=0");
        }

        const testWall = BABYLON.MeshBuilder.CreateBox("testWall", { width: 5, height: 5, depth: 1 }, scene);
        testWall.position = new BABYLON.Vector3(15, 2.5, 0);
        testWall.checkCollisions = true;
        testWall.isPickable = true;
        testWall.material = new BABYLON.StandardMaterial("wallMat", scene);
        testWall.material.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
        console.log("Test wall created at (15, 2.5, 0)");

        try {
          console.log("Loading audio...");
          backgroundMusic = new BABYLON.Sound("backgroundMusic", "./assets/background_music.mp3", scene, () => {
            console.log("Background music loaded");
            backgroundMusic.setVolume(0.3);
            backgroundMusic.loop = true;
          }, { autoplay: false });
          monsterAlertSound = new BABYLON.Sound("monsterAlert", "./assets/monster_alert.mp3", scene, () => {
            console.log("Monster alert sound loaded");
            monsterAlertSound.setVolume(0.5);
          }, { autoplay: false });
        } catch (error) {
          console.error("Failed to load audio:", error);
          document.getElementById("loadingMsg").innerText = "Warning: Audio failed to load.";
        }

        const monsters = [];
        const spawnMonsters = () => {
          console.log("Spawning monsters...");
          const positions = [
            new BABYLON.Vector3(20, 1, 0),
            new BABYLON.Vector3(-20, 1, 0),
            new BABYLON.Vector3(0, 1, 20)
          ];
          for (let i = 0; i < 3; i++) {
            const monster = new Monster(positions[i], scene);
            monster.setRandomPatrolTarget();
            monsters.push(monster);
          }
        };

        const lightSphere = BABYLON.MeshBuilder.CreateSphere("light", { diameter: 1 }, scene);
        lightSphere.position = lightPosition;
        lightSphere.material = new BABYLON.StandardMaterial("lightMaterial", scene);
        lightSphere.material.emissiveColor = new BABYLON.Color3(0.8, 1, 0.8);
        lightSphere.checkCollisions = false;

        const guideLight = BABYLON.MeshBuilder.CreateSphere("guideLight", { diameter: 0.3 }, scene);
        guideLight.material = new BABYLON.StandardMaterial("guideLightMaterial", scene);
        guideLight.material.emissiveColor = new BABYLON.Color3(0.2, 0.8, 0.2);
        guideLight.checkCollisions = false;

        const stealth = new StealthMechanic(camera, scene);

        const quitGame = () => {
          console.log("Quitting game...");
          if (gameStarted) {
            document.getElementById("instructions").style.display = "none";
            document.getElementById("staminaBarContainer").style.display = "none";
            document.getElementById("warningMsg").style.display = "none";
            document.getElementById("quitButton").style.display = "none";
            document.getElementById("uiOverlay").style.display = "flex";
            document.getElementById("gameOverOverlay").style.display = "none";
            document.getElementById("winOverlay").style.display = "none";
            if (backgroundMusic) backgroundMusic.stop();
            if (monsterAlertSound) monsterAlertSound.stop();
            engine.stopRenderLoop();
            if (scene) {
              scene.dispose();
              scene = null;
            }
            gameStarted = false;
            inputMap = {};
            monsters = [];
            lastPosition = null;
            stuckTime = 0;
            console.log("Game quit successfully");
          }
        };

        scene.onBeforeRenderObservable.add(() => {
          if (!scene || !gameStarted) return;

          if (inputMap["escape"]) {
            quitGame();
            inputMap["escape"] = false;
            return;
          }

          if (inputMap["shift"] && stamina > 0) {
            isSprinting = true;
            camera.speed = 1.2;
            stamina -= 0.5;
          } else {
            isSprinting = false;
            camera.speed = 0.8;
            if (stamina < 100) stamina += 0.2;
          }

          document.getElementById("staminaBar").style.width = `${stamina}%`;

          if (inputMap[" "] && canJump && !isClimbing) {
            camera.cameraDirection.y += 0.3;
            canJump = false;
            console.log("Jump triggered");
            setTimeout(() => { canJump = true; }, 800);
          }

          if (inputMap["c"] && !isCrouching && !isClimbing) {
            camera.applyGravity = false;
            camera.position.y -= 0.5;
            camera.ellipsoid.y = 0.6;
            isCrouching = true;
            console.log(`Crouch started: y = ${camera.position.y}`);
          } else if (!inputMap["c"] && isCrouching) {
            camera.position.y += 0.5;
            camera.ellipsoid.y = 0.9;
            camera.applyGravity = true;
            isCrouching = false;
            console.log(`Crouch ended: y = ${camera.position.y}`);
          }

          if (inputMap["e"] && !isCrouching && !isClimbing) {
            camera.applyGravity = false;
            camera.checkCollisions = false;
            camera.cameraDirection.y += 0.4;
            isClimbing = true;
            climbStartTime = performance.now();
            console.log(`Climbing up: y = ${camera.position.y}`);
          } else if (inputMap["q"] && !isCrouching && !isClimbing) {
            camera.applyGravity = false;
            camera.checkCollisions = false;
            camera.cameraDirection.y -= 0.4;
            isClimbing = true;
            climbStartTime = performance.now();
            console.log(`Climbing down: y = ${camera.position.y}`);
          } else if ((inputMap["e"] || inputMap["q"]) && isClimbing && performance.now() - climbStartTime > 1000) {
            camera.applyGravity = true;
            camera.checkCollisions = true;
            isClimbing = false;
            console.log(`Climbing stopped: y = ${camera.position.y}`);
          } else if (!inputMap["e"] && !inputMap["q"] && isClimbing) {
            camera.applyGravity = true;
            camera.checkCollisions = true;
            isClimbing = false;
            console.log(`Climbing stopped: y = ${camera.position.y}`);
          }

          const directionToLight = lightPosition.subtract(camera.position);
          directionToLight.y = 0;
          directionToLight.normalize();
          guideLight.position = camera.position.add(directionToLight.scale(4));
          guideLight.position.y = 1.5;

          if (lastPosition) {
            const dist = BABYLON.Vector3.Distance(new BABYLON.Vector3(camera.position.x, 0, camera.position.z), new BABYLON.Vector3(lastPosition.x, 0, lastPosition.z));
            if (dist < 0.1 && (inputMap["w"] || inputMap["a"] || inputMap["s"] || inputMap["d"])) {
              stuckTime += scene.getEngine().getDeltaTime();
              if (stuckTime > 2000) {
                console.warn("Player stuck! Teleporting...");
                document.getElementById("warningMsg").innerText = "Stuck in terrain! Teleporting forward.";
                document.getElementById("warningMsg").style.display = "block";
                camera.position.y += 2;
                camera.position.z += 0.5;
                stuckTime = 0;
              }
            } else {
              stuckTime = 0;
            }
          }
          lastPosition = camera.position.clone();

          stealth.update();
          let closestMonster = null;
          let closestDistance = Infinity;
          monsters.forEach(monster => {
            const distance = monster.getDistanceToPlayer(camera);
            if (distance < closestDistance) {
              closestDistance = distance;
              closestMonster = monster;
            }
            monster.detectPlayer(camera, stealth.isHiding);
            monster.update();
            if (distance < 1.5 && monster.isLoaded) {
              console.log("Collision: Monster caught player at distance", distance);
              document.getElementById("instructions").style.display = "none";
              document.getElementById("staminaBarContainer").style.display = "none";
              document.getElementById("warningMsg").style.display = "none";
              document.getElementById("quitButton").style.display = "none";
              document.getElementById("gameOverOverlay").style.display = "flex";
              if (isAuthenticated) fetchTotalTokens();
              else document.getElementsByName("totalTokensDisplay").forEach(el => {
                el.innerText = `Total ORNG Tokens Collected: 0`;
              });
              if (backgroundMusic) backgroundMusic.stop();
              if (monsterAlertSound) monsterAlertSound.stop();
              gameStarted = false;
            }
          });

          const warningMsg = document.getElementById("warningMsg");
          if (closestDistance < 10 && !stealth.isHiding && closestMonster && closestMonster.isLoaded) {
            if (!closestMonster.isPaused) {
              closestMonster.pauseForObservation();
            }
            if (monsterAlertSound && performance.now() - lastMonsterWarning > 3000) {
              monsterAlertSound.play();
              lastMonsterWarning = performance.now();
            }
            const playerForward = camera.getDirection(new BABYLON.Vector3(0, 0, 1));
            playerForward.y = 0;
            playerForward.normalize();
            const monsterPos = closestMonster.mesh.position;
            const monsterDir = monsterPos.subtract(camera.position);
            monsterDir.y = 0;
            monsterDir.normalize();
            const dot = BABYLON.Vector3.Dot(playerForward, monsterDir);
            const cross = playerForward.x * monsterDir.z - playerForward.z * monsterDir.x;
            const phi = Math.atan2(cross, dot);
            let direction;
            if (Math.abs(phi) < Math.PI / 4) {
              direction = "in front";
            } else if (Math.abs(phi) > 3 * Math.PI / 4) {
              direction = "behind";
            } else if (phi > 0) {
              direction = "to your left";
            } else {
              direction = "to your right";
            }
            warningMsg.innerHTML = `Monster Nearby! ${direction}! Escape to the glowing light!`;
            warningMsg.style.display = "block";
          } else if (!warningMsg.innerHTML.includes("Stuck")) {
            warningMsg.style.display = "none";
          }

          const distanceToLight = BABYLON.Vector3.Distance(camera.position, lightPosition);
          if (distanceToLight < 3 && gameStarted) {
            elapsedTime = (performance.now() - startTime) / 1000;
            console.log("Win condition met: Distance to light =", distanceToLight, "Elapsed time =", elapsedTime);
            awardTokens(elapsedTime).then(reward => {
              const winMessage = isAuthenticated
                ? `You escaped to the glowing light in ${elapsedTime.toFixed(1)} seconds, earning ${reward.tokens} ORNG tokens!`
                : `You escaped to the glowing light in ${elapsedTime.toFixed(1)} seconds! No ORNG tokens earned (login required).`;
              document.getElementById("winMessage").innerHTML = winMessage;
              if (!reward.success && isAuthenticated) {
                console.warn("Reward submission failed.");
              }
              console.log("Win: Reached glowing light");
              document.getElementById("instructions").style.display = "none";
              document.getElementById("staminaBarContainer").style.display = "none";
              document.getElementById("warningMsg").style.display = "none";
              document.getElementById("quitButton").style.display = "none";
              document.getElementById("winOverlay").style.display = "flex";
              if (isAuthenticated) fetchTotalTokens();
              else document.getElementsByName("totalTokensDisplay").forEach(el => {
                el.innerText = `Total ORNG Tokens Collected: 0`;
              });
              if (backgroundMusic) backgroundMusic.stop();
              if (monsterAlertSound) monsterAlertSound.stop();
              gameStarted = false;
            });
          }

          if (camera.position.y < 0) {
            console.error("Player falling! Camera position:", camera.position);
            document.getElementById("warningMsg").innerText = "Falling! Teleporting up.";
            document.getElementById("warningMsg").style.display = "block";
            camera.position = new BABYLON.Vector3(camera.position.x, 5, camera.position.z);
          }

          console.log("Camera position:", camera.position, "Inputs:", Object.keys(inputMap).filter(k => inputMap[k]));
        });

        engine.runRenderLoop(() => {
          if (scene && gameStarted) {
            scene.render();
          }
        });

        return { scene, spawnMonsters, monsters, quitGame };
      };

      const startNewGame = () => {
        console.log("Starting new game...");
        document.getElementById("uiOverlay").style.display = "none";
        document.getElementById("gameOverOverlay").style.display = "none";
        document.getElementById("winOverlay").style.display = "none";
        document.getElementById("instructions").style.display = "block";
        document.getElementById("staminaBarContainer").style.display = "block";
        document.getElementById("quitButton").style.display = "block";
        gameStarted = true;
        startTime = performance.now();
        lastPosition = null;
        stuckTime = 0;

        canvas.focus();
        console.log("Canvas focused for input");

        if (scene) {
          scene.dispose();
          scene = null;
        }

        createScene(getRandomLightPosition()).then(({ scene: s, spawnMonsters: sm, monsters: m, quitGame: qg }) => {
          scene = s;
          spawnMonsters = sm;
          monsters = m;
          quitGame = qg;
          document.getElementById("loadingMsg").style.display = "none";
          console.log("Scene created");
          if (backgroundMusic) backgroundMusic.play();

          setTimeout(() => {
            if (gameStarted && spawnMonsters) {
              spawnMonsters();
            }
          }, 7000);
        }).catch(error => {
          console.error("Scene creation failed:", error);
          document.getElementById("loadingMsg").innerText = "Error: Failed to load game. Check Console.";
        });
      };

      console.log("Initializing scene...");
      createScene().then(({ scene: s, spawnMonsters: sm, monsters: m, quitGame: qg }) => {
        scene = s;
        spawnMonsters = sm;
        monsters = m;
        quitGame = qg;
        document.getElementById("loadingMsg").style.display = "none";
        console.log("Initial scene loaded");
      }).catch(error => {
        console.error("Initial scene failed:", error);
        document.getElementById("loadingMsg").innerText = "Error: Failed to load game. Check Console.";
      });

      document.getElementById("startButton").addEventListener("click", startNewGame);

      document.getElementById("exitButton").addEventListener("click", () => {
        console.log("Exit clicked");
        window.location.href = window.location.pathname;
      });

      document.getElementById("restartButtonGameOver").addEventListener("click", () => {
        console.log("Restart from game over");
        document.getElementById("gameOverOverlay").style.display = "none";
        startNewGame();
      });

      document.getElementById("restartButtonWin").addEventListener("click", () => {
        console.log("Restart from win");
        document.getElementById("winOverlay").style.display = "none";
        startNewGame();
      });

      document.getElementById("quitButton").addEventListener("click", () => {
        console.log("Quit button clicked");
        if (gameStarted) {
          quitGame();
        }
      });

      document.getElementById("voteButton").addEventListener("click", voteForGame);
      document.getElementById("voteButtonWin").addEventListener("click", voteForGame);

      window.addEventListener("resize", () => {
        engine.resize();
      });

      window.addEventListener("load", () => {
        console.log("Window loaded, checking session...");
        checkSession();
        handleCallback();
        if (!isAuthenticated) {
          document.getElementsByName("totalTokensDisplay").forEach(el => {
            el.innerText = `Total ORNG Tokens Collected: 0`;
          });
        }
      });
    })();
  </script>
</body>
</html>